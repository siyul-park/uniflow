package plugin

import (
	"context"

	"github.com/stretchr/testify/mock"
)

// Mock is an autogenerated mock type for the Plugin type
type Mock struct {
	mock.Mock
}

var _ Plugin = (*Mock)(nil)

// NewMock creates a new Plugin mock and registers the node interface with cleanup.
func NewMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *Mock {
	m := &Mock{}
	m.Mock.Test(t)
	t.Cleanup(func() { m.AssertExpectations(t) })
	return m
}

// SetXXX mocks the Set* method.
func (m *Mock) SetXXX(val any) error {
	ret := m.Called(val)

	if len(ret) == 0 {
		panic("no return receiver specified for SetXXX")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(any) error); ok {
		r0 = rf(val)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Name mocks the Name method.
func (m *Mock) Name() string {
	ret := m.Called()

	var r0 string
	if fn, ok := ret.Get(0).(func() string); ok {
		r0 = fn()
	} else {
		r0 = ret.String(0)
	}
	return r0
}

// Version mocks the Version method.
func (m *Mock) Version() string {
	ret := m.Called()

	var r0 string
	if fn, ok := ret.Get(0).(func() string); ok {
		r0 = fn()
	} else {
		r0 = ret.String(0)
	}
	return r0
}

// Load mocks the Load method.
func (m *Mock) Load(ctx context.Context) error {
	ret := m.Called(ctx)

	if len(ret) == 0 {
		panic("no return receiver specified for Load")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// Unload mocks the Unload method.
func (m *Mock) Unload(ctx context.Context) error {
	ret := m.Called(ctx)

	if len(ret) == 0 {
		panic("no return receiver specified for Unload")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}
